{
  "name": "Azure-sdk-for-php",
  "tagline": "Microsoft Azure SDK for PHP",
  "body": "# Microsoft Azure SDK for PHP\r\n\r\nThis project provides a set of PHP client libraries that make it easy to access\r\nMicrosoft Azure tables, blobs, queues, service bus (queues and topics), service runtime and service management APIs. For documentation on how to host PHP applications on Microsoft Azure, please see the\r\n[Microsoft Azure PHP Developer Center](http://www.windowsazure.com/en-us/develop/php/).\r\n\r\n# Features\r\n\r\n* Tables\r\n  * create and delete tables\r\n  * create, query, insert, update, merge, and delete entities\r\n  * batch operations\r\n  * REST API Version: see https://github.com/Azure/azure-storage-php\r\n* Blobs\r\n  * create, list, and delete containers, work with container metadata and permissions, list blobs in container\r\n  * create block and page blobs (from a stream or a string), work with blob blocks and pages, delete blobs\r\n  * work with blob properties, metadata, leases, snapshot a blob\r\n  * REST API Version: see https://github.com/Azure/azure-storage-php\r\n* Storage Queues\r\n  * create, list, and delete queues, and work with queue metadata and properties\r\n  * create, get, peek, update, delete messages\r\n  * REST API Version: see https://github.com/Azure/azure-storage-php\r\n* Service Bus\r\n  * Queues: create, list and delete queues; send, receive, unlock and delete messages\r\n  * Topics: create, list, and delete topics; create, list, and delete subscriptions; send, receive, unlock and delete messages; create, list, and delete rules\r\n* Service Runtime\r\n  * discover addresses and ports for the endpoints of other role instances in your service\r\n  * get configuration settings and access local resources\r\n  * get role instance information for current role and other role instances\r\n  * query and set the status of the current role\r\n  * REST API Version: 2011-03-08\r\n* Service Management\r\n  * storage accounts: create, update, delete, list, regenerate keys\r\n  * affinity groups: create, update, delete, list, get properties\r\n  * locations: list\r\n  * hosted services: create, update, delete, list, get properties\r\n  * deployment: create, get, delete, swap, change configuration, update status, upgrade, rollback\r\n  * role instance: reboot, reimage\r\n  * REST API Version: 2011-10-01\r\n* Media Services \r\n  * Connection\r\n  * Ingest asset, upload files\r\n  * Encoding / process asset, create job, job templates\r\n  * Manage media services entities: create / update / read / delete / get list\r\n  * Delivery SAS and Streaming media content\r\n  * Dynamic encryption: AES and DRM (PlayReady/Widevine/FairPlay) with and without Token restriction\r\n  * Scale encoding reserved unit type\r\n  * REST API Version: 2.12\r\n\r\n  \r\n# Getting Started\r\n## Download Source Code\r\n\r\nTo get the source code from GitHub, type\r\n\r\n    git clone https://github.com/Azure/azure-sdk-for-php.git\r\n    cd ./azure-sdk-for-php\r\n\r\n> **Note**\r\n> \r\n> The PHP Client Libraries for Microsoft Azure have a dependency on the [HTTP_Request2](http://pear.php.net/package/HTTP_Request2), [Mail_mime](http://pear.php.net/package/Mail_mime), and [Mail_mimeDecode](http://pear.php.net/package/Mail_mimeDecode) PEAR packages. The recommended way to resolve these dependencies is to install them using the [Composer package manager](http://getcomposer.org).\r\n\r\n\r\n##Install via Composer\r\n\r\n* Create a file named **composer.json** in the root of your project and add the following code to it:\r\n```json\r\n    {\r\n        \"require\": {        \r\n            \"microsoft/windowsazure\": \"^0.4\"\r\n        }  \r\n    }\r\n```\r\n\r\n* Download **[composer.phar](http://getcomposer.org/composer.phar)** in your project root.\r\n\r\n* Open a command prompt and execute this in your project root\r\n\r\n    php composer.phar install\r\n\r\n  > **Note**\r\n  >\r\n  > On Windows, you will also need to add the Git executable to your PATH environment variable.\r\n\r\n# Usage\r\n\r\n## Getting Started\r\n\r\nThere are four basic steps that have to be performed before you can make a call to any Microsoft Azure API when using the libraries. \r\n\r\n* First, include the autoloader script:\r\n\r\n    require_once \"vendor/autoload.php\"; \r\n  \r\n* Include the namespaces you are going to use.\r\n\r\n  To create any Microsoft Azure service client you need to use the **ServicesBuilder** class:\r\n\r\n    use WindowsAzure\\Common\\ServicesBuilder;\r\n\r\n  To process exceptions you need:\r\n\r\n    use WindowsAzure\\Common\\ServiceException;\r\n\r\n  \r\n* To instantiate the service client you will also need a valid connection string. The format is: \r\n\r\n  * For accessing a live storage service (tables, blobs, queues):\r\n  \r\n      DefaultEndpointsProtocol=[http|https];AccountName=[yourAccount];AccountKey=[yourKey]\r\n  \r\n  * For accessing the emulator storage:\r\n  \r\n      UseDevelopmentStorage=true\r\n\r\n  * For accessing the Service Bus:\r\n\r\n      Endpoint=[yourEndpoint];SharedSecretIssuer=[yourWrapAuthenticationName];SharedSecretValue=[yourWrapPassword]\r\n\r\n    Where the Endpoint is typically of the format `https://[yourNamespace].servicebus.windows.net`.\r\n\r\n  * For accessing Service Management APIs:\r\n\r\n      SubscriptionID=[yourSubscriptionId];CertificatePath=[filePathToYourCertificate]\r\n\r\n\r\n* Instantiate a \"REST Proxy\" - a wrapper around the available calls for the given service.\r\n\r\n  * For the Storage services:\r\n\r\n      $tableRestProxy = ServicesBuilder::getInstance()->createTableService($connectionString);\r\n      $blobRestProxy = ServicesBuilder::getInstance()->createBlobService($connectionString);\r\n      $queueRestProxy = ServicesBuilder::getInstance()->createQueueService($connectionString);\r\n\r\n  * For Service Bus:\r\n\r\n      $serviceBusRestProxy = ServicesBuilder::getInstance()->createServiceBusService($connectionString);\r\n\r\n  * For Service Management:\r\n\r\n      $serviceManagementRestProxy = ServicesBuilder::getInstance()->createServiceManagementService($connectionString);\r\n\r\n  * For Media Services:\r\n\r\n      $mediaServicesRestProxy = ServicesBuilder->getInstance()->createMediaServicesService(new MediaServicesSettings([YourAccountName], [YourPrimaryOrSecondaryAccessKey]));\r\n\r\n## Table Storage\r\n\r\nThe following are examples of common operations performed with the Table serivce. For more please read [How-to use the Table service](http://www.windowsazure.com/en-us/develop/php/how-to-guides/table-service/).\r\n\r\n### Create a table\r\n\r\nTo create a table call **createTable**:\r\n\r\n```PHP\r\ntry {\r\n  // Create table.\r\n  $tableRestProxy->createTable(\"mytable\");\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n[Error Codes and Messages for Tables](http://msdn.microsoft.com/en-us/library/windowsazure/dd179438.aspx)\r\n\r\n### Insert an entity\r\n\r\nTo add an entity to a table, create a new **Entity** object and pass it to **TableRestProxy->insertEntity**. Note that when you create an entity you must specify a `PartitionKey` and `RowKey`. These are the unique identifiers for an entity and are values that can be queried much faster than other entity properties. The system uses `PartitionKey` to automatically distribute the table’s entities over many storage nodes.\r\n\r\n```PHP\r\nuse MicrosoftAzure\\Storage\\Table\\Models\\Entity;\r\nuse MicrosoftAzure\\Storage\\Table\\Models\\EdmType;\r\n\r\n$entity = new Entity();\r\n$entity->setPartitionKey(\"pk\");\r\n$entity->setRowKey(\"1\");\r\n$entity->addProperty(\"PropertyName\", EdmType::STRING, \"Sample\");\r\n\r\ntry{\r\n  $tableRestProxy->insertEntity(\"mytable\", $entity);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Query entities\r\n\r\nTo query for entities you can call **queryEntities**. The subset of entities you retrieve will be determined by the filter you use (for more information, see [Querying Tables and Entities](http://msdn.microsoft.com/en-us/library/windowsazure/dd894031.aspx)). You can also provide no filter at all.\r\n\r\n```PHP\r\n$filter = \"RowKey eq '2'\";\r\n\r\ntry {\r\n  $result = $tableRestProxy->queryEntities(\"mytable\", $filter);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n\r\n$entities = $result->getEntities();\r\n\r\nforeach($entities as $entity){\r\n  echo $entity->getPartitionKey().\":\".$entity->getRowKey().\"<br />\";\r\n}\r\n```\r\n\r\n## Blob Storage\r\n\r\nTo get started using the Blob service you must include the `BlobService` and `BlobSettings` namespaces and set the `ACCOUNT_NAME` and `ACCOUNT_KEY` configuration settings for your credentials. Then you instantiate the wrapper using the `BlobService` factory.\r\n\r\nThe following are examples of common operations performed with the Blob serivce. For more please read [How-to use the Blob service](http://www.windowsazure.com/en-us/develop/php/how-to-guides/blob-service/).\r\n\r\n\r\n### Create a container\r\n\r\n```PHP\r\n// OPTIONAL: Set public access policy and metadata.\r\n// Create container options object.\r\n$createContainerOptions = new CreateContainerOptions(); \r\n\r\n// Set public access policy. Possible values are \r\n// PublicAccessType::CONTAINER_AND_BLOBS and PublicAccessType::BLOBS_ONLY.\r\n// CONTAINER_AND_BLOBS: full public read access for container and blob data.\r\n// BLOBS_ONLY: public read access for blobs. Container data not available.\r\n// If this value is not specified, container data is private to the account owner.\r\n$createContainerOptions->setPublicAccess(PublicAccessType::CONTAINER_AND_BLOBS);\r\n\r\n// Set container metadata\r\n$createContainerOptions->addMetaData(\"key1\", \"value1\");\r\n$createContainerOptions->addMetaData(\"key2\", \"value2\");\r\n\r\ntry {\r\n  // Create container.\r\n  $blobRestProxy->createContainer(\"mycontainer\", $createContainerOptions);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n[Error Codes and Messages for Blobs](http://msdn.microsoft.com/en-us/library/windowsazure/dd179439.aspx)\r\n\r\nFor more information about container ACLs, see [Set Container ACL (REST API)](http://msdn.microsoft.com/en-us/library/windowsazure/dd179391.aspx).\r\n\r\n### Upload a blob\r\n\r\nTo upload a file as a blob, use the **BlobRestProxy->createBlockBlob** method. This operation will create the blob if it doesn’t exist, or overwrite it if it does. The code example below assumes that the container has already been created and uses [fopen](http://www.php.net/fopen) to open the file as a stream.\r\n\r\n```PHP\r\n$content = fopen(\"myfile.txt\", \"r\");\r\n$blob_name = \"myblob\";\r\n\r\ntry {\r\n  //Upload blob\r\n  $blobRestProxy->createBlockBlob(\"mycontainer\", $blob_name, $content);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\nWhile the example above uploads a blob as a stream, a blob can also be uploaded as a string.\r\n\r\n### List blobs in a container\r\n\r\nTo list the blobs in a container, use the **BlobRestProxy->listBlobs** method with a **foreach** loop to loop through the result. The following code outputs the name and URI of each blob in a container.\r\n\r\n```PHP\r\ntry {\r\n  // List blobs.\r\n  $blob_list = $blobRestProxy->listBlobs(\"mycontainer\");\r\n  $blobs = $blob_list->getBlobs();\r\n  \r\n  foreach($blobs as $blob)\r\n  {\r\n    echo $blob->getName().\": \".$blob->getUrl().\"<br />\";\r\n  }\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n\r\n## Storage Queues\r\n\r\nTo get started using the Queue service you must include the `QueueService` and `QueueSettings` namespaces and set the `ACCOUNT_NAME` and `ACCOUNT_KEY` configuration settings for your credentials. Then you instantiate the wrapper using the `QueueService` factory.\r\n\r\nThe following are examples of common operations performed with the Queue serivce. For more please read [How-to use the Queue service](http://www.windowsazure.com/en-us/develop/php/how-to-guides/queue-service/).\r\n\r\n\r\n### Create a queue\r\n\r\nA **QueueRestProxy** object lets you create a queue with the **createQueue** method. When creating a queue, you can set options on the queue, but doing so is not required.\r\n\r\n```PHP\r\n$createQueueOptions = new CreateQueueOptions();\r\n$createQueueOptions->addMetaData(\"key1\", \"value1\");\r\n$createQueueOptions->addMetaData(\"key2\", \"value2\");\r\n\r\ntry {\r\n  // Create queue.\r\n  $queueRestProxy->createQueue(\"myqueue\", $createQueueOptions);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n[Error Codes and Messages for Queues](http://msdn.microsoft.com/en-us/library/windowsazure/dd179446.aspx)\r\n  \r\n\r\n### Add a message to a queue\r\n\r\nTo add a message to a queue, use **QueueRestProxy->createMessage**. The method takes the queue name, the message text, and message options (which are optional).\r\nFor compatibility with others you may need to base64 encode message.\r\n\r\n```PHP\r\ntry {\r\n  // Create message.\r\n  $msg = \"Hello World!\";\r\n  // optional: $msg = base64_encode($msg);\r\n  $queueRestProxy->createMessage(\"myqueue\", $msg);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Peek at the next message\r\n\r\nYou can peek at a message (or messages) at the front of a queue without removing it from the queue by calling **QueueRestProxy->peekMessages**.\r\n\r\n```PHP\r\n// OPTIONAL: Set peek message options.\r\n$message_options = new PeekMessagesOptions();\r\n$message_options->setNumberOfMessages(1); // Default value is 1.\r\n\r\ntry {\r\n  $peekMessagesResult = $queueRestProxy->peekMessages(\"myqueue\", $message_options);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n\r\n$messages = $peekMessagesResult->getQueueMessages();\r\n\r\n// View messages.\r\n$messageCount = count($messages);\r\nif($messageCount <= 0){\r\n  echo \"There are no messages.<br />\";\r\n}\r\nelse{\r\n  foreach($messages as $message)  {\r\n    echo \"Peeked message:<br />\";\r\n    echo \"Message Id: \".$message->getMessageId().\"<br />\";\r\n    echo \"Date: \".date_format($message->getInsertionDate(), 'Y-m-d').\"<br />\";\r\n    echo \"Message text: \".$message->getMessageText().\"<br /><br />\";\r\n  }\r\n}\r\n```\r\n\r\n### De-queue the next message\r\n\r\nYour code removes a message from a queue in two steps. First, you call **QueueRestProxy->listMessages**, which makes the message invisible to any other code reading from the queue. By default, this message will stay invisible for 30 seconds (if the message is not deleted in this time period, it will become visible on the queue again). To finish removing the message from the queue, you must call **QueueRestProxy->deleteMessage**.\r\n\r\n```PHP\r\n// Get message.\r\n$listMessagesResult = $queueRestProxy->listMessages(\"myqueue\");\r\n$messages = $listMessagesResult->getQueueMessages();\r\n$message = $messages[0];\r\n\r\n// Process message\r\n\r\n// Get message Id and pop receipt.\r\n$messageId = $message->getMessageId();\r\n$popReceipt = $message->getPopReceipt();\r\n\r\ntry {\r\n  // Delete message.\r\n  $queueRestProxy->deleteMessage(\"myqueue\", $messageId, $popReceipt);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n## Service Bus Queues\r\nThe current PHP Service Bus APIs only support ACS connection strings. You need to use PowerShell to create a new ACS Service Bus namespace at the present time.  \r\nFirst, make sure you have Azure PowerShell installed, then in a PowerShell command prompt, run \r\n```\r\nAdd-AzureAccount # this will sign you in\r\nNew-AzureSBNamespace -CreateACSNamespace $true -Name 'mytestbusname' -Location 'West US' -NamespaceType 'Messaging'\r\n```\r\nIf it is sucessful, you will get the connection string in the PowerShell output. If you get connection errors with it and the conection string looks like Endpoint=sb://..., change it to **Endpoint=https://...**\r\n \r\n### Create a Queue\r\n\r\n```PHP\r\ntry {\r\n  $queueInfo = new QueueInfo(\"myqueue\");\r\n  \r\n  // Create queue.\r\n  $serviceBusRestProxy->createQueue($queueInfo);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n[Error Codes and Messages](http://msdn.microsoft.com/en-us/library/windowsazure/dd179357)\r\n\r\n### Send a Message\r\n\r\nTo send a message to a Service Bus queue, your application will call the **ServiceBusRestProxy->sendQueueMessage** method. Messages sent to (and received from ) Service Bus queues are instances\r\nof the **BrokeredMessage** class.\r\n\r\n```PHP\r\ntry {\r\n  // Create message.\r\n  $message = new BrokeredMessage();\r\n  $message->setBody(\"my message\");\r\n\r\n  // Send message.\r\n  $serviceBusRestProxy->sendQueueMessage(\"myqueue\", $message);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Receive a Message\r\n\r\nThe primary way to receive messages from a queue is to use a **ServiceBusRestProxy->receiveQueueMessage** method. Messages can be received in two different modes: **ReceiveAndDelete** (mark message as consumed on read) and **PeekLock** (locks message for a period of time, but does not delete).\r\n\r\nThe example below demonstrates how a message can be received and processed using **PeekLock** mode (not the default mode).\r\n\r\n```PHP\r\ntry {\r\n  // Set the receive mode to PeekLock (default is ReceiveAndDelete).\r\n  $options = new ReceiveMessageOptions();\r\n  $options->setPeekLock(true);\r\n  \r\n  // Receive message.\r\n  $message = $serviceBusRestProxy->receiveQueueMessage(\"myqueue\", $options);\r\n  echo \"Body: \".$message->getBody().\"<br />\";\r\n  echo \"MessageID: \".$message->getMessageId().\"<br />\";\r\n  \r\n  // *** Process message here ***\r\n  \r\n  // Delete message.\r\n  $serviceBusRestProxy->deleteMessage($message);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n## Service Bus Topics\r\n\r\n### Create a Topic\r\n\r\n```PHP\r\ntry {   \r\n  // Create topic.\r\n  $topicInfo = new TopicInfo(\"mytopic\");\r\n  $serviceBusRestProxy->createTopic($topicInfo);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Create a subscription with the default (MatchAll) filter\r\n\r\n```PHP\r\ntry {\r\n  // Create subscription.\r\n  $subscriptionInfo = new SubscriptionInfo(\"mysubscription\");\r\n  $serviceBusRestProxy->createSubscription(\"mytopic\", $subscriptionInfo);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Send a message to a topic\r\n\r\nMessages sent to Service Bus topics are instances of the **BrokeredMessage** class.\r\n\r\n```PHP\r\ntry {\r\n  // Create message.\r\n  $message = new BrokeredMessage();\r\n  $message->setBody(\"my message\");\r\n\r\n  // Send message.\r\n  $serviceBusRestProxy->sendTopicMessage(\"mytopic\", $message);\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n### Receive a message from a topic\r\n\r\nThe primary way to receive messages from a subscription is to use a **ServiceBusRestProxy->receiveSubscriptionMessage** method. Received messages can work in two different modes: **ReceiveAndDelete** (the default) and **PeekLock** similarly to Service Bus Queues.\r\n\r\nThe example below demonstrates how a message can be received and processed using **ReceiveAndDelete** mode (the default mode). \r\n\r\n```PHP\r\ntry {\r\n  // Set receive mode to PeekLock (default is ReceiveAndDelete)\r\n  $options = new ReceiveMessageOptions();\r\n  $options->setReceiveAndDelete();\r\n\r\n  // Get message.\r\n  $message = $serviceBusRestProxy->receiveSubscriptionMessage(\"mytopic\", \r\n                                \"mysubscription\", \r\n                                $options);\r\n  echo \"Body: \".$message->getBody().\"<br />\";\r\n  echo \"MessageID: \".$message->getMessageId().\"<br />\";\r\n} catch(ServiceException $e){\r\n  $code = $e->getCode();\r\n  $error_message = $e->getMessage();\r\n  echo $code.\": \".$error_message.\"<br />\";\r\n}\r\n```\r\n\r\n## Service Management\r\n\r\n### Set-up certificates\r\n\r\nYou  need to create two certificates, one for the server (a .cer file) and one for the client (a .pem file). To create the .pem file using [OpenSSL](http://www.openssl.org), execute this: \r\n\r\n  openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem\r\n\r\nTo create the .cer certificate, execute this: \r\n\r\n  openssl x509 -inform pem -in mycert.pem -outform der -out mycert.cer\r\n\r\n### List Available Locations\r\n\r\n```PHP  \r\n$serviceManagementRestProxy->listLocations();\r\n$locations = $result->getLocations();\r\nforeach($locations as $location){\r\n      echo $location->getName().\"<br />\";\r\n}\r\n```\r\n\r\n### Create a Storage Service\r\n\r\nTo create a storage service, you need a name for the service (between 3 and 24 lowercase characters and unique within Microsoft Azure), a label (a base-64 encoded name for the service, up to 100 characters), and either a location or an affinity group. Providing a description for the service is optional.\r\n\r\n```PHP\r\n$name = \"mystorageservice\";\r\n$label = base64_encode($name);\r\n$options = new CreateStorageServiceOptions();\r\n$options->setLocation('West US');\r\n\r\n$result = $serviceManagementRestProxy->createStorageService($name, $label, $options);\r\n```\r\n  \r\n  \r\n### Create a Cloud Service\r\n\r\nA cloud service is also known as a hosted service (from earlier versions of Microsoft Azure).  The **createHostedServices** method allows you to create a new hosted service by providing a hosted service name (which must be unique in Microsoft Azure), a label (the base 64-endcoded hosted service name), and a **CreateServiceOptions** object which allows you to set the location *or* the affinity group for your service. \r\n\r\n```PHP\r\n$name = \"myhostedservice\";\r\n$label = base64_encode($name);\r\n$options = new CreateServiceOptions();\r\n$options->setLocation('West US');\r\n// Instead of setLocation, you can use setAffinityGroup to set an affinity group.\r\n\r\n$result = $serviceManagementRestProxy->createHostedService($name, $label, $options);\r\n```\r\n\r\n### Create a Deployment\r\n\r\nTo make a new deployment to Azure you must store the package file in a Microsoft Azure Blob Storage account under the same subscription as the hosted service to which the package is being uploaded. You can create a deployment package with the [Microsoft Azure PowerShell cmdlets](https://www.windowsazure.com/en-us/develop/php/how-to-guides/powershell-cmdlets/), or with the [cspack commandline tool](http://msdn.microsoft.com/en-us/library/windowsazure/gg432988.aspx).\r\n\r\n```PHP\r\n$hostedServiceName = \"myhostedservice\";\r\n$deploymentName = \"v1\";\r\n$slot = DeploymentSlot::PRODUCTION;\r\n$packageUrl = \"URL_for_.cspkg_file\";\r\n$configuration = file_get_contents('path_to_.cscfg_file');\r\n$label = base64_encode($hostedServiceName);\r\n\r\n$result = $serviceManagementRestProxy->createDeployment($hostedServiceName,\r\n                         $deploymentName,\r\n                         $slot,\r\n                         $packageUrl,\r\n                         $configuration,\r\n                         $label);\r\n\r\n$status = $serviceManagementRestProxy->getOperationStatus($result);\r\necho \"Operation status: \".$status->getStatus().\"<br />\";\r\n```\r\n\r\n##Media Services\r\n \r\n###Create new asset with file\r\n\r\nTo create an asset with a file you need to create an empty asset, create access policy with write permission, create a locator joining your asset and access policy, perform actual upload and generate file info.\r\n```PHP\r\n$asset = new Asset(Asset::OPTIONS_NONE);\r\n$asset = $restProxy->createAsset($asset);\r\n\r\n$access = new AccessPolicy('[Some access policy name]');\r\n$access->setDurationInMinutes([Munites AccessPolicy is valid]);\r\n$access->setPermissions(AccessPolicy::PERMISSIONS_WRITE);\r\n$access = $restProxy->createAccessPolicy($access);\r\n\r\n$sasLocator = new Locator($asset,  $access, Locator::TYPE_SAS);\r\n$sasLocator->setStartTime(new \\DateTime('now -5 minutes'));\r\n$sasLocator = $restProxy->createLocator($sasLocator);\r\n\r\n$restProxy->uploadAssetFile($sasLocator, '[file name]', '[file content]');\r\n$restProxy->createFileInfos($asset);\r\n```\r\n\r\n###Encode asset\r\n\r\nTo perform media file encoding you will need input asset ($inputAsset) with a file in it (something like in previous chapter). Also you need to create an array of task data objects and a job data object. To create a task object use a media processor, task XML body and configuration name.\r\n```PHP\r\n$mediaProcessor = $this->restProxy->getLatestMediaProcessor('[Media processor]');\r\n\r\n$task = new Task('[Task XML body]', $mediaProcessor->getId(), TaskOptions::NONE);\r\n$task->setConfiguration('[Configuration name]');\r\n\r\n$restProxy->createJob(new Job(), array($inputAsset), array($task));\r\n```\r\n\r\n###Get public URL to encoded asset\r\n\r\nAfter you’ve uploaded a media file and encode it you can get a download URL for that file or a streaming URL for multiple bitrate files. Create a new access policy with read permission and link it with job output asset via locator.\r\n\r\n```PHP\r\n$accessPolicy = new AccessPolicy('[Some access policy name]');\r\n$accessPolicy->setDurationInMinutes([Munites AccessPolicy is valid]);\r\n$accessPolicy->setPermissions(AccessPolicy::PERMISSIONS_READ);\r\n$accessPolicy = $restProxy->createAccessPolicy($accessPolicy);\r\n\r\n// Download URL\r\n$sasLocator = new Locator($asset, $accessPolicy, Locator::TYPE_SAS);\r\n$sasLocator->setStartTime(new \\DateTime('now -5 minutes'));\r\n$sasLocator = $restProxy->createLocator($sasLocator);\r\n\r\n// Azure needs time to publish media\r\nsleep(30);\r\n\r\n$downloadUrl = $sasLocator->getBaseUri() . '/' . '[File name]' . $sasLocator->getContentAccessComponent()\r\n\r\n// Streaming URL\r\n$originLocator = new Locator($asset, $accessPolicy, Locator::TYPE_ON_DEMAND_ORIGIN);\r\n$originLocator = $restProxy->createLocator($originLocator);\r\n\r\n// Azure needs time to publish media\r\nsleep(30);\r\n\r\n$streamingUrl = $originLocator->getPath() . '[Manifest file name]' . \"/manifest\";\r\n```\r\n\r\n###Manage media services entities\r\n\r\nMedia services CRUD operations are performed through media services rest proxy class. It has methods like “createAsset”, “createLocator”, “createJob” and etc. for entities creations. \r\n\r\nTo retrieve all entities list you may use methods “getAssetList”, “getAccessPolicyList”, “getLocatorList”, “getJobList” and etc. For getting single entity data use methods “getAsset”, “getJob”, “getTask” and etc. passing the entity identifier or entity data model object with non-empty identifier as a parameter. \r\n\r\nUpdate entities with methods like “updateLocator”, “updateAsset”, “updateAssetFile” and etc. passing the entity data model object as a parameter. It is important to have valid entity identifier specified in data model object. \r\n\r\nErase entities with methods like “deleteAsset”, “deleteAccessPolicy”, “deleteJob” and etc. passing the entity identifier or entity data model object with non-empty identifier as a parameter.\r\n\r\nAlso you could get linked entities with methods “getAssetLocators”, “getAssetParentAssets”, “getAssetStorageAccount”, “getLocatorAccessPolicy”, “getJobTasks” and etc. passing the entity identifier or entity data model object with non-empty identifier as a parameter.\r\n\r\nThe complete list of all methods available you could find in [IMediaServices](src/MediaServices/Internal/IMediaServices.php) interface.\r\n\r\n**For more examples please see the [Microsoft Azure PHP Developer Center](http://www.windowsazure.com/en-us/develop/php)**\r\n\r\n# Need Help?\r\n\r\nBe sure to check out the Microsoft Azure [Developer Forums on Stack Overflow](http://go.microsoft.com/fwlink/?LinkId=234489) if you have trouble with the provided code.\r\n\r\n# Contribute Code or Provide Feedback\r\n\r\nIf you would like to become an active contributor to this project please follow the instructions provided in [Microsoft Azure Projects Contribution Guidelines](http://windowsazure.github.com/guidelines.html).\r\n\r\nTo setup your development environment, follow the instructions in this [wiki page](https://github.com/Azure/azure-sdk-for-php/wiki/Devbox-installation-guide).\r\n\r\nIf you encounter any bugs with the library please file an issue in the [Issues](https://github.com/Azure/azure-sdk-for-php/issues) section of the project.\r\n\r\n# Learn More\r\n[Microsoft Azure PHP Developer Center](http://www.windowsazure.com/en-us/develop/php/)\r\n\r\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or\r\ncontact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}